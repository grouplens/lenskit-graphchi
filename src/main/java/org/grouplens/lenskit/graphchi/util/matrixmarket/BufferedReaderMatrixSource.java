package org.grouplens.lenskit.graphchi.util.matrixmarket;
import  org.grouplens.lenskit.cursors.AbstractPollingCursor;
import org.grouplens.lenskit.graphchi.util.MatrixEntry;

import java.io.FileReader;
import java.io.IOException;
import java.io.BufferedReader;
import java.util.regex.Pattern;

/**
 * The MatrixSource designed to read from a dense matrix in matrix market format. It wraps a file handle and
 * parses the matrix line by line.
 * Currently no support for reading a sparse matrix is provided.
 *
 * All of it's methods make no attempt to handle IO exceptions.
 *
 * @author Daniel Gratzer < danny.gratzer@gmail.com >
 */
public class BufferedReaderMatrixSource extends AbstractPollingCursor<MatrixEntry> implements MatrixSource{
    private int columns;
    private int rows;
    private int entries;
    private boolean isSorted;
    private BufferedReader inputSource;
    private MatrixEntry entry;
    private static Pattern whiteSpacePattern = Pattern.compile("\\s+");

    private int currentColumn = -1; //Starts negative to allow for initial increment in parseLine()
    private int currentRow    =  0;

    /*
     * A private constructor which takes in metadata associated with the matrix.
     */
    private BufferedReaderMatrixSource(BufferedReader inputSource, int rows, int columns, int entries, boolean isSorted){
        super(entries);
        this.columns = columns;
        this.rows = rows;
        this.entries = entries;
        this.isSorted = isSorted;
        this.inputSource = inputSource;
        entry = new MatrixEntry();
    }

    /**
     * The factory used for generating dense BufferedReaderMatrixSources.
     *
     * @param filename The filename for the target matrix
     * @param hasMetadata Used to determine if the file should be scanned twice to determine metadata information. It is
     *                    true for all matrices generated by GraphChi
     * @param isSorted   Used to for the MatrixSource interfaces function <code>isSorted()</code>
     * @return A new BufferedReaderMatrixSource which wraps the target dense matrix market matrix.
     * @throws IOException If any IOException occurs during the process of opening the file and reading metadata it is thrown.
     */
    public static BufferedReaderMatrixSource getDenseMatrixSource(String filename, boolean hasMetadata, boolean isSorted) throws IOException{
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        if(hasMetadata){
            reader.mark(1);
            while(reader.read()=='%'){
                reader.readLine();
                reader.mark(1);
            }
            reader.reset();
            String[] metadata = whiteSpacePattern.split(reader.readLine());
            int rows = Integer.parseInt(metadata[0]);
            int columns = Integer.parseInt(metadata[1]);
            return new BufferedReaderMatrixSource(reader, rows, columns, rows*columns, isSorted);
        }
        else{
            int entries = 0;
            for(String line; (line = reader.readLine()) != null; ++entries){
                if(line.charAt(0) == '%')
                    --entries;
            }
            return new BufferedReaderMatrixSource(new BufferedReader(new FileReader(filename)), -1, -1, entries, isSorted);
        }
    }

    public int getMatrixColumnCount(){
        return columns;
    }
    public int getMatrixRowCount(){
        return rows;
    }
    public int getMatrixEntryCount(){
        return entries;
    }
    public boolean isSorted(){
        return isSorted;
    }

    @Override
    public int getRowCount(){
       return entries;
    }

    /**
     * Parses and returns the next line.
     *
     * @return The next line of our Matrix wrapped in a MatrixEntry or null if we have reached the end of the file.
     */
    public MatrixEntry poll(){
        return parseLine()? entry : null;
    }

    /**
     * Closes the filehandle for the matrix market file.
     */
    public void close(){
        try{
            inputSource.close();
        }
        catch(IOException e){
            throw new RuntimeException("Error while closing BufferedReader");
        }
    }

    /*
     * Parses the current line, throws a runtime exception if any IO occurs.
     *
     * Updates the currentRow and currentColumn variables.
     */
    private boolean parseLine(){
        String nextLine;
        try{
            nextLine = inputSource.readLine();
        }
        catch(IOException e){
            //If this happens, major things are wrong, crash hard.
            throw new RuntimeException("Error while reading from file ");
        }
        if(nextLine==null)
            return false;

        double rating = Double.parseDouble(nextLine);
        ++currentColumn;
        if(currentColumn == columns){
            ++currentRow;
            currentColumn = 0;
        }

        entry.set(currentRow, currentColumn, rating);
        return true;
    }

}

